<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>SS服务器搭建教程</title>
      <link href="/2019/04/20/vultr-ss-bbr-kcptun/"/>
      <url>/2019/04/20/vultr-ss-bbr-kcptun/</url>
      <content type="html"><![CDATA[<p>本文旨在快速<del>学习Linux</del>搭建 <a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="noopener">shadowsocks</a> 服务(以下简称ss)，并利用 <a href="https://github.com/google/bbr" title="bbr" target="_blank" rel="noopener">bbr</a> 和 <a href="https://github.com/skywind3000/kcp" title="kcp" target="_blank" rel="noopener">kcp</a> 进行加速，然后在 windows/ios 设备上愉悦地网上冲浪。</p><p><strong>注意：本文基于你对 linux 操作系统有简单的认知和理解，所以本文并不适合纯小白</strong></p><p><strong>以下是需要用到的资源</strong></p><ul><li>一台可访国际互联网的服务器</li><li>ss 服务端一键安装脚本：<a href="https://github.com/flyzy2005/ss-fly" title="ss-fly" target="_blank" rel="noopener">ss-fly</a></li><li>kcptun 服务端：<a href="https://github.com/xtaci/kcptun" title="kcptun" target="_blank" rel="noopener">kcptun</a>（非必须）</li><li>kcptun 客户端：<a href="https://github.com/xtaci/kcptun" title="kcptun" target="_blank" rel="noopener">kcptun</a>（非必须)</li><li>ss windows 客户端：<a href="https://github.com/shadowsocks/shadowsocks-windows" title="shadowsocks windows" target="_blank" rel="noopener">shadowsocks-windows</a></li><li>ss ios 客户端：<a href="https://itunes.apple.com/us/app/potatso-lite/id1239860606?mt=8" title="potatso lite" target="_blank" rel="noopener">potatso lite</a></li></ul><h2 id="一、-获取服务器"><a href="#一、-获取服务器" class="headerlink" title="一、 获取服务器"></a>一、 获取服务器</h2><p>选购一台<strong>廉价</strong>的海外服务器就足够了，本文使用 <a href="https://www.vultr.com/?ref=8030646-4F" title="vultr" target="_blank" rel="noopener">vultr</a> 提供的 vps，目前最便宜的是$3.5一个月。使用下面的推广链接可获得$50首冲赠送。</p><p>推广链接：<a href="https://www.vultr.com/?ref=8030646-4F" target="_blank" rel="noopener">https://www.vultr.com/?ref=8030646-4F</a></p><p><em>注意：推广活动是限时的，如果点击过去发现无效，就表示活动过期了。</em></p><h2 id="二、-安装ss服务端"><a href="#二、-安装ss服务端" class="headerlink" title="二、 安装ss服务端"></a>二、 安装ss服务端</h2><p>服务端的安装方式有很多，本文选用 <a href="https://github.com/flyzy2005" target="_blank" rel="noopener">@flyzy2005</a> 编写的 <a href="https://github.com/flyzy2005/ss-fly" title="ss-fly" target="_blank" rel="noopener">ss-fly</a> 一键安装脚本。</p><h3 id="第一步：clone代码到本地"><a href="#第一步：clone代码到本地" class="headerlink" title="第一步：clone代码到本地"></a>第一步：clone代码到本地</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/flyzy2005/ss-fly</span><br></pre></td></tr></table></figure><h3 id="第二步：运行安装脚本"><a href="#第二步：运行安装脚本" class="headerlink" title="第二步：运行安装脚本"></a>第二步：运行安装脚本</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly<span class="selector-class">.sh</span> -<span class="selector-tag">i</span> yourpassword <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>其中<code>yourpassword</code>是 ss 连接密码，<code>8080</code>是端口号。</p><p>等待安装完成即可，安装完成之后服务会自动运行，并会开机自启。</p><p>如果需要修改密码或者端口，只需要<strong>重新运行一次安装脚本</strong>，或者直接修改<code>/etc/shadowsocks.json</code>这个配置文件。</p><p>相关操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ss-fly start        <span class="comment"># 启动</span></span><br><span class="line">/etc/init.d/ss-fly stop         <span class="comment"># 停止</span></span><br><span class="line">/etc/init.d/ss-fly restart      <span class="comment"># 重启</span></span><br><span class="line">/etc/init.d/ss-fly status       <span class="comment"># 查看状态</span></span><br><span class="line">ss-fly/ss-fly.sh -sslink        <span class="comment"># 查看连接</span></span><br><span class="line">vi /etc/shadowsocks.json        <span class="comment"># 修改配置</span></span><br></pre></td></tr></table></figure></p><h3 id="第三步：验证服务状态"><a href="#第三步：验证服务状态" class="headerlink" title="第三步：验证服务状态"></a>第三步：验证服务状态</h3><p>这一步并不是必须的，而是为了检查 ss 服务是否在<strong>正常运行</strong>，并<strong>能被外部网络访问</strong></p><h4 id="在服务器上执行"><a href="#在服务器上执行" class="headerlink" title="在服务器上执行"></a>在服务器上执行</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -lntup</span></span><br></pre></td></tr></table></figure><p>检查输出结果是否有一个被 python 监听的<code>8080</code>端口，如果有就说明 ss 服务已经启动。</p><h4 id="在本地执行"><a href="#在本地执行" class="headerlink" title="在本地执行"></a>在本地执行</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet yourserverip <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>其中<code>yourserverip</code>是你的服务器 ip，如果连接成功，就表示 ss 服务已经能被外部网络访问。</p><p>如果没有<code>telnet</code>这个命令，可以在<code>控制面板 &gt; 程序和功能 &gt; 启用或关闭 Windows 功能</code>中勾选<code>Telnet Client</code>并安装。</p><p>如果<code>telnet</code>连接失败，可以检查以下几个方面：</p><ol><li>服务器防火墙是否开放<code>8080</code>端口（<a href="https://github.com/flyzy2005/ss-fly" title="ss-fly" target="_blank" rel="noopener">ss-fly</a> 在安装过程中会自动配置防火墙开放<code>8080</code>）；</li><li>服务器提供商的防火墙策略是否开放<code>8080</code>（<a href="https://www.vultr.com/?ref=8030646-4F" title="vultr" target="_blank" rel="noopener">vultr</a> 默认无防火墙）；</li><li>你所在的网络是否允许访问<code>8080</code>，由于一些企业的防火墙策略只允许访问常用端口，所以本文使用的是<code>8080</code>这种比较常用的端口；</li></ol><h2 id="三、-安装SS客户端"><a href="#三、-安装SS客户端" class="headerlink" title="三、 安装SS客户端"></a>三、 安装SS客户端</h2><p>ss 客户端也有很多，本文选用 <a href="https://github.com/shadowsocks/shadowsocks-windows" title="shadowsocks windows" target="_blank" rel="noopener">shadowsocks-windows</a>，使用方法非常简单，填写好<code>服务器地址`</code>服务器端口<code></code>密码`就可以正常使用了，记得更新PAC配置。</p><p><strong>到这里，ss 服务端和 windows 客户端就已经安装完成了，已经可以正常的网上冲浪了。</strong></p><p>如果你觉得冲浪的速度有点差强人意，那么你可以继续进行下面的步骤。</p><h2 id="四、-开启BBR加速"><a href="#四、-开启BBR加速" class="headerlink" title="四、 开启BBR加速"></a>四、 开启BBR加速</h2><p><a href="https://github.com/google/bbr" title="bbr" target="_blank" rel="noopener">bbr</a> 是 <a href="https://github.com/google" target="_blank" rel="noopener">@google</a> 开源的一套内核加速算法，可以让你搭建的 shadowsocks 速度上一个台阶。</p><p>本文使用的<code>ss-fly</code>一键安装脚本已经集成了<code>bbr</code>的一键安装，所以我们只需要在服务器上运行以下脚本就可以开启<code>bbr</code>加速了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly<span class="selector-class">.sh</span> -bbr</span><br></pre></td></tr></table></figure><p><strong>注意：安装完成之后需要重启系统才能生效。</strong></p><p>检测<code>bbr</code>加速是否开启，可以输入以下脚本：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_available_congestion_control</span></span><br></pre></td></tr></table></figure><p>如果返回类似以下这种<strong>后面含有<code>bbr</code></strong>的内容，则说明已经成功开启了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_available_congestion_control</span> = bbr cubic reno</span><br></pre></td></tr></table></figure><p><strong>到这里，你不但完成了 ss 服务端和 windows 客户端的安装，还对服务端的 ss 进行了 bbr 加速。</strong></p><p>这基本能满足大多数冲浪需求了，但如果你像本文一样，购买的是非常廉价而且又远在美利坚的 vps，每到晚上速度就会慢得让人接受不了，那么你可以继续下面的步骤。</p><h2 id="五、-使用KCPTUN进行加速"><a href="#五、-使用KCPTUN进行加速" class="headerlink" title="五、 使用KCPTUN进行加速"></a>五、 使用KCPTUN进行加速</h2><p><a href="https://github.com/xtaci/kcptun" title="kcptun" target="_blank" rel="noopener">kcptun</a> 是由 <a href="https://github.com/xtaci" target="_blank" rel="noopener">@xtaci</a> 基于 <a href="https://github.com/skywind3000/kcp" title="kcp" target="_blank" rel="noopener">kcp</a> 协议的<code>golang</code>实现。KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p><p><strong>注意：使用<code>kcptun</code>会增加流量的开支</strong></p><p>但是对于本文中使用的 <a href="https://www.vultr.com/?ref=8030646-4F" title="vultr" target="_blank" rel="noopener">vultr</a> vps 最低配，也就是 500G/month 的流量限制，完全能够负担。</p><h3 id="下载最新版的kcptun"><a href="#下载最新版的kcptun" class="headerlink" title="下载最新版的kcptun"></a>下载最新版的kcptun</h3><p>打开 <a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="noopener">https://github.com/xtaci/kcptun/releases</a> 在服务器上下载最新版的<code>kcptun</code>服务端<code>kcptun-linux-amd64-20xxxxxx.tar.gz</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本文使用的 v20190418</span></span><br><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/xtaci/</span>kcptun<span class="regexp">/releases/</span>download<span class="regexp">/v20190418/</span>kcptun-linux-amd64-<span class="number">20190418</span>.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后启动服务</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./server_linux_amd64</span> -t <span class="string">"yourssip:8080"</span> -l <span class="string">":8081"</span> -mode fast3 -nocomp -sockbuf 16777217 -dscp 46 <span class="params">--key</span> yourpassword</span><br><span class="line"><span class="comment"># 这里是直接在当前服务器会话运行的，你可以使用 nohup 让它在后台运行，也可以注册成 systemd 服务让它以服务的形式启动</span></span><br></pre></td></tr></table></figure><p>其中<code>yourssip</code>是你的 ss 服务器 ip，在本文中 ss 和 kcptun 部署在同一服务器，所以这里直接填写服务器的 ip 地址，<code>8080</code>是你的 ss 端口，<code>8081</code>是你准备让<code>kcptun</code>监听的端口，<code>yourpassword</code>是你的<code>kcptun</code>密码。</p><p>你任然可以使用<code>netstat -lntup</code>来查看<code>8081</code>端口的监听情况，以便确认<code>kcptun</code>是否启动成功</p><p><strong>这样，kcptun 服务端就已经部署好了</strong></p><p>接下来下载最新版的 windows 客户端<code>kcptun-windows-amd64-20xxxxxx.tar.gz</code>，解压之后会发现里面包含 windows 服务端和客户端文件，由于我们的服务端已经部署在 linux 上，所以我们只需要名为<code>client_windows_amd64.exe</code>的客户端文件。</p><p>我们用<code>cmd</code>运行以下脚本</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_windows_amd64.exe -r <span class="string">"KCP_SERVER_IP:8081"</span> -l <span class="string">":1000"</span> -mode fast3 -nocomp -sockbuf <span class="number">16777217</span> -dscp <span class="number">46</span> --<span class="type">key</span> yourpassword</span><br></pre></td></tr></table></figure><p>其中<code>KCP_SERVER_IP</code>是你的<code>kcptun</code>所在服务器的 ip，<code>8081</code>是你的<code>kcptun</code>监听的端口，<code>:1000</code>是你的<code>kcptun</code>客户端准备监听的本地端口，<code>yourpassword</code>是你的<code>kcptun</code>密码。</p><p>这样我们的<code>kcptun</code>客户端就已经成功连接到了我们的<code>kcptun</code>服务端，接下来我们只需要修改一下我们的<code>shadowsocks-windows</code>客户端的配置，让<code>shadowsocks-windows</code>不把数据发送到 ss 服务器，而是把数据发送到本地的<code>kcptun</code>，就能实现我们的<code>kcptun</code>加速了。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#   <span class="function"><span class="title">ss</span>客户端 -&gt;</span> <span class="function"><span class="title">kcptun</span>客户端 -&gt;</span> <span class="function"><span class="title">kcptun</span>服务端 -&gt;</span> ss服务端</span><br></pre></td></tr></table></figure><p><strong>shadowsocks-windows 配置修改</strong></p><p>将<code>服务器地址</code>改为<code>127.0.0.1</code>，将<code>服务器端口</code>改为<code>1000</code>，确认之后就可以享受<code>kcptun</code>加速带来的稳定和快乐了。</p><h2 id="六、整合shadowsocks-windows和kcptun客户端"><a href="#六、整合shadowsocks-windows和kcptun客户端" class="headerlink" title="六、整合shadowsocks-windows和kcptun客户端"></a>六、整合shadowsocks-windows和kcptun客户端</h2><p>到上一步的时候，由于我们在客户端每次都要开启两个程序（kcptun客户端、ss客户端），所以在使用上显得并不那么优雅。好在<code>shadowsocks-windows</code>提供了插件的支持，我们可以把<code>kcptun</code>以插件的形式加载到<code>shadowsocks-windows</code>，使得我们只需要启动<code>shadowsocks-windows</code>就可以愉快的冲浪。</p><ol><li>复制<code>client_windows_amd64.exe</code>到<code>shadowsocks-windows</code>目录；</li><li>修改<code>shadowsocks-windows</code>配置，将<code>服务器地址</code>改为<code>ss服务器地址</code>，将<code>服务器端口</code>改为<code>8081</code>（服务端<code>kcptun</code>监听的端口），<code>插件程序</code>填写<code>client_windows_amd64.exe</code>，<code>插件参数</code>填写以下内容<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">r %SS_REMOTE_HOST%<span class="symbol">:%SS_REMOTE_PORT%</span> -l %SS_LOCAL_HOST%<span class="symbol">:%SS_LOCAL_PORT%</span> --mode fast3 --nocomp --sockbuf <span class="number">16777217</span> --dscp <span class="number">46</span> --key kcptunpassword</span></span><br><span class="line"><span class="ruby"><span class="comment"># kcptunpassword 是你的 kcptun 密码</span></span></span><br></pre></td></tr></table></figure></li></ol><p>确认之后就可以享受<code>kcptun</code>加速带来的稳定和快乐了。</p><h2 id="七、-IOS客户端"><a href="#七、-IOS客户端" class="headerlink" title="七、 IOS客户端"></a>七、 IOS客户端</h2><p>国区已经没有好用的 ss 客户端了，本文使用的 <a href="https://itunes.apple.com/us/app/potatso-lite/id1239860606?mt=8" title="potatso lite" target="_blank" rel="noopener">potatso lite</a> 也需要在美区才能下载，关于如何切换美区，或者注册美区账号，以下提供简要的说明，避免大家踩坑<del>根本没有人会浏览到我的博客，哪儿来的大家</del>。</p><ol><li>需要能访问真正互联网的网络，推荐使用 <a href="https://www.nutsvpn.com/" target="_blank" rel="noopener">nuts</a> 的 ios 版；</li><li>不要用 wifi 代理，用代理无法访问 appstore；</li><li>需要一个美国身份的生成器，不要乱填，乱填无法通过验证，推荐使用 <a href="https://www.fakenamegenerator.com/gen-male-us-us.php" target="_blank" rel="noopener">fake name generator</a></li></ol>]]></content>
      
      <categories>
          
          <category> ladder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ss </tag>
            
            <tag> vultr </tag>
            
            <tag> bbr </tag>
            
            <tag> kcptun </tag>
            
            <tag> potatso </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git分支管理</title>
      <link href="/2018/03/08/git-branch-management/"/>
      <url>/2018/03/08/git-branch-management/</url>
      <content type="html"><![CDATA[<h2 id="1-总览"><a href="#1-总览" class="headerlink" title="1. 总览"></a>1. 总览</h2><p>git 的分支整体预览图如下</p><p><img src="/2018/03/08/git-branch-management/branches.png" alt="分支总览"></p><p>从上图可以看到主要包含下面几个分支：</p><ul><li>master: 主分支，主要用来版本发布。</li><li>develop：日常开发分支，该分支正常保存了开发的最新代码。</li><li>feature：具体的功能开发分支，只与 develop 分支交互。</li><li>release：release 分支可以认为是 master 分支的未测试版。比如说某一期的功能全部开发完成，那么就 将 develop 分支合并到 release 分支，测试没有问题并且到了发布日期就合并到 master 分支，进行发 布。</li><li>hotfix：线上 bug 修复分支。</li></ul><a id="more"></a><h2 id="2-主分支"><a href="#2-主分支" class="headerlink" title="2. 主分支"></a>2. 主分支</h2><p>主分支包括 master 分支和 develop 分支。master 分支用来发布，HEAD 就是当前线上的运行代码。develop 分支就是我们的日常开发。使用这两个分支就具有了最简单的开发模式：develop 分支用来开发功能，开发完成并且测试没有问题则将 develop 分支的代码合并到 master 分支并发布。</p><p><img src="/2018/03/08/git-branch-management/master&amp;develop.png" alt="主分支"></p><p>这引入了几个问题：</p><ol><li>develop 分支只有发布完了才能进行下一个版本开发，开发会比较缓慢。</li><li>线上代码出现 bug 如何进行 bug 修复。</li></ol><p>带着这两个问题往下看。</p><h2 id="3-辅助分支"><a href="#3-辅助分支" class="headerlink" title="3. 辅助分支"></a>3. 辅助分支</h2><p>主要介绍的辅助分支如下：</p><ul><li>feature 分支</li><li>release 分支</li><li>hotfix 分支</li></ul><p>通过这些分支，我们可以做到：团队成员之间并行开发，feature track 更加容易，开发和发布并行以及线上问题修复。</p><h3 id="3-1-Feature-分支"><a href="#3-1-Feature-分支" class="headerlink" title="3.1 Feature 分支"></a>3.1 Feature 分支</h3><p>feature 分支用来开发具体的功能，一般 fork 自 develop 分支，最终可能会合并到 develop 分支。比如我们要在下一个版本增加功能1、功能2、功能3。那么我们就可以起三个feature 分支：feature1，feature2，feature3。（feature 分支命名最好能够自解释，这并不是一种好的命名。）随着我们开发，功能1和功能2都被完成了，而功能3因为某些原因完成不了，那么最终 feature1 和 feature2 分支将被合并到 develop 分支，而 feature3 分支将被干掉。</p><p><img src="/2018/03/08/git-branch-management/feature.png" alt="feature分支"></p><h3 id="3-2-Release-分支"><a href="#3-2-Release-分支" class="headerlink" title="3.2 Release 分支"></a>3.2 Release 分支</h3><p>release 分支在我看来是 pre-master。release 分支从 develop 分支 fork 出来，最终会合并到 develop 分支和 master 分支。合并到 master 分支上就是可以发布的代码了。有人可能会问那为什么合并回 develop 分支呢？很简单，有了 release 分支，那么相关的代码修复就只会在 release 分支上改动了，最后必然要合并到 develop 分支。</p><p>我们最初所有的开发工作都在 develop 分支上，当我们这一期的功能开发完毕的时候，我们基于 develop 分支开一个新的 release 分支。这个时候我们就可以对 release 分支做统一的测试了，另外做一些发布准备工作：比如版本号之类的。</p><p>如果测试工作或者发布准备工作和具体的开发工作由不同人来做，比如国内的 RD 和 QA，这个 RD 就可以继续基于 develop 分支继续开发了。再或者说公司对于发布有严格的时间控制，开发工作提前并且完美的完成了，这个时候我们就可以在 develop 分支上继续我们下一期的开发了。同时如果测试有问题的话，我们将直接在 release 分支上修改，然后将修改合并到 develop 分支上。</p><p>待所有的测试和准备工作做完之后，我们就可以将 release 分支合并到 master 分支上，并进行发布了。</p><h3 id="3-3-Hotfix-分支"><a href="#3-3-Hotfix-分支" class="headerlink" title="3.3 Hotfix 分支"></a>3.3 Hotfix 分支</h3><p>顾名思义，hotfix 分支用来修复线上 bug。当线上代码出现 bug 时，我们基于 master 分支开一个 hotfix 分支，修复 bug 之后再将 hotfix 分支合并到 master 分支并进行发布，同时 develop 分支作为最新最全的代码分支，hotfix 分支也需要合并到 develop 分支上去。仔细想一想，其实 hotfix 分支和 release 分支功能类似。hotfix 的好处是不打断 develop 分支正常进行，同时对于现实代码的修复貌似也没有更好的方法了（总不能直接修改 master 代码吧:D）。</p><p><img src="/2018/03/08/git-branch-management/hotfix.png" alt="hotfix分支"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://nvie.com/posts/a-successful-git-branching-model" target="_blank" rel="noopener">A successful Git branching model</a></li></ol>]]></content>
      
      <categories>
          
          <category> work </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Nginx中“no resolver defined to resolve xxx.xxx“的问题</title>
      <link href="/2017/04/23/nginx-error-no-resolver-defined-to-resolve/"/>
      <url>/2017/04/23/nginx-error-no-resolver-defined-to-resolve/</url>
      <content type="html"><![CDATA[<p>在 Nginx 配置文件中使用变量来存放一个http地址时，如果这个地址是域名而不是IP，如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> <span class="variable">$server_domain</span>          <span class="string">"http://yourdomain:8080"</span>;</span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> <span class="variable">$server_domain</span>;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/api/?(.*)$</span> <span class="string">"/<span class="variable">$1</span>"</span> <span class="literal">break</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host       <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置中的代理是会出错的，错误信息是</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">no</span> resolver defined <span class="keyword">to</span> <span class="built_in">resolve</span> yourdomain</span><br></pre></td></tr></table></figure><p>但是如果我们不申明变量 $server_domain，而是直接设置 proxy_pass</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://yourdomain:8080;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/api/?(.*)$</span> <span class="string">"/<span class="variable">$1</span>"</span> <span class="literal">break</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host       <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候代理就会生效，毫无问题</p><p>原因是 Nginx 0.6.18以后的版本中启用了一个resolver指令，在使用变量来构造某个server地址的时候一定要用resolver指令来指定DNS服务器的地址，所以解决这个问题的方法很简单：在nginx的配置文件中的http{}部分添加一行DNS地址即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">resolver</span> 8<span class="selector-class">.8</span><span class="selector-class">.8</span><span class="selector-class">.8</span>;</span><br></pre></td></tr></table></figure><p>此外，如果有ipv6环境的机器，还可以加上ipv6=off指令，避免一些奇葩原因导致的no resolver defined to resolve错误。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span> ipv6=off;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> work </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECMAScript6 编码规范</title>
      <link href="/2016/07/09/ecmascript6-coding-standards/"/>
      <url>/2016/07/09/ecmascript6-coding-standards/</url>
      <content type="html"><![CDATA[<p>本规范是基于JavaScript规范拟定的，只针对ES6相关内容进行约定</p><p>如变量命名，是否加分号等约定的请参考JavaScript规范</p><p>应注意目前的代码转换工具(如Babel，Traceur)不够完善,有些特性须谨慎使用</p><h2 id="规范内容"><a href="#规范内容" class="headerlink" title="规范内容"></a>规范内容</h2><ol><li><a href="#声明">声明 Declarations</a></li><li><a href="#字符串">字符串 Strings</a></li><li><a href="#解构">解构 Destructuring</a></li><li><a href="#数组">数组 Arrays</a></li><li><a href="#函数">函数 Functions</a></li><li><a href="#类">类 Classes</a></li><li><a href="#模块">模块 Modules</a></li></ol><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>1.1 变量</li></ul><p>对于只在当前作用域下有效的变量，应使用<code>let</code>来代替<code>var</code></p><p>对于全局变量声明，采用<code>var</code>，但应避免声明过多全局变量污染环境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> variables;</span><br><span class="line"><span class="keyword">const</span> globalObj = <span class="literal">null</span>; <span class="comment">// 不是常量</span></span><br><span class="line"><span class="keyword">let</span> globalObj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">let</span> variables;</span><br><span class="line"><span class="keyword">var</span> globalObj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><ul><li>1.2 常量</li></ul><p>对于常量应使用<code>const</code>进行声明，命名采用驼峰写法</p><p>对于使用 immutable 数据应用<code>const</code>进行声明</p><p>注意: <code>const</code>与<code>let</code>只在声明所在的块级作用域内有效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">let</span> someNum = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> AnotherStr = <span class="string">'不变的字符串'</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'不'</span>, <span class="string">'变'</span>, <span class="string">'数'</span>, <span class="string">'组'</span>];</span><br><span class="line"><span class="keyword">var</span> ANOTHER_OBJ = &#123;</span><br><span class="line">  <span class="string">'不变对象'</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> someNum = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> anotherStr = <span class="string">'不变的字符串'</span>;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'不'</span>, <span class="string">'变'</span>, <span class="string">'数'</span>, <span class="string">'组'</span>];</span><br><span class="line"><span class="keyword">const</span> anotherObj = &#123;</span><br><span class="line">  <span class="string">'不变对象'</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>2.1 处理多行字符串,使用模板字符串</li></ul><p>以反引号( ` )标示</p><p>可读性更强，代码更易编写</p><p>注意排版引起空格的问题，使用场景为声明HTML模板字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> tmpl = <span class="string">'&lt;div class="content"&gt; \n'</span> +</span><br><span class="line">              <span class="string">'&lt;h1&gt;这是换行了。&lt;/h1&gt; \n'</span> +</span><br><span class="line">            <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> tmpl = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class="content"&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;这是换行了。&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br></pre></td></tr></table></figure><ul><li>2.2 处理字符串拼接变量时,使用模板字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'How are you, '</span> + name + <span class="string">'?'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`How are you, <span class="subst">$&#123;name&#125;</span>?`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><ul><li>3.1 嵌套结构的对象层数不能超过3层</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="string">'one'</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'newTwo'</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">'three'</span>: [</span><br><span class="line">            <span class="string">'four'</span>: <span class="string">'太多层了，头晕晕'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="string">'one'</span>: [</span><br><span class="line">    <span class="string">'two'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'twoObj'</span>: <span class="string">'结构清晰'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>3.2 解构语句中统一不使用圆括号</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line">[(a)] = [<span class="number">11</span>]; <span class="comment">// a未定义</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: (b) &#125; = &#123;&#125;; <span class="comment">// 解析出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">11</span>, <span class="number">22</span>];</span><br></pre></td></tr></table></figure><ul><li>3.3 对象解构</li></ul><p>对象解构 元素与顺序无关</p><p>对象指定默认值时仅对恒等于undefined ( !== null ) 的情况生效</p><ul><li>3.3.1 若函数形参为对象时，使用对象解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someFun</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> opt1 = opt.opt1;</span><br><span class="line">  <span class="keyword">let</span> opt2 = opt.opt2;</span><br><span class="line">  <span class="built_in">console</span>.log(op1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someFun</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; opt1, opt2 &#125; = opt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`$(opt1) 加上 $(opt2)`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someFun</span>(<span class="params">&#123; opt1, opt2 &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(opt1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.3.2 若函数有多个返回值时，使用对象解构，不使用数组解构，避免添加顺序的问题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> one = <span class="number">1</span>, two = <span class="number">2</span>, three = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> [one, two, three];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [one, three, two] = anotherFun(); <span class="comment">// 顺序乱了</span></span><br><span class="line"><span class="comment">// one = 1, two = 3, three = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> one = <span class="number">1</span>, two = <span class="number">2</span>, three = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; one, two, three &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; one, three, two &#125; = anotherFun(); <span class="comment">// 不用管顺序</span></span><br><span class="line"><span class="comment">// one = 1, two = 2, three = 3</span></span><br></pre></td></tr></table></figure><ul><li>3.3.3 已声明的变量不能用于解构赋值（语法错误）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">&#123; a &#125; = &#123; <span class="attr">b</span>: <span class="number">123</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>3.4 数组解构</li></ul><p>数组元素与顺序相关</p><ul><li>3.4.1 交换变量的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">let</span> temp;</span><br><span class="line">temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line">[x, y] = [y, x]; <span class="comment">// 交换变量</span></span><br></pre></td></tr></table></figure><ul><li>3.4.2 将数组成员赋值给变量时，使用数组解构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> one = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> two = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> [one, two] = arr;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li>4.1 将类数组(array-like)对象与可遍历对象(如<code>Set</code>, <code>Map</code>)转为真正数组</li></ul><p>采用<code>Array.from</code>进行转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4.2 数组去重</li></ul><p>结合<code>Set</code>结构与<code>Array.from</code></p><p>使用indexOf，HashTable等形式，不够简洁清晰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deduplication</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4.3 数组拷贝</li></ul><p>采用数组扩展<code>...</code>形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> len = items.length;</span><br><span class="line"><span class="keyword">let</span> copyTemp = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  copyTemp[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">let</span> copyTemp = [...items];</span><br></pre></td></tr></table></figure><ul><li>4.4 将一组数值转为数组</li></ul><p>采用<code>Array.of</code>进行转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>); <span class="comment">// [undefined x 2]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">2</span>);  <span class="comment">// [2]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li>5.1 当要用函数表达式或匿名函数时，使用箭头函数(Arrow Functions)</li></ul><p>箭头函数更加简洁，并且绑定了this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo.name); <span class="comment">// 返回'' ，函数表达式默认省略name属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testObj = &#123;</span><br><span class="line">  name: <span class="string">'testObj'</span>,</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>; <span class="comment">// 保存定义时的this引用</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _this.doSth();</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSth() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo.name); <span class="comment">// 返回'foo'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map( <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testObj = &#123;</span><br><span class="line">  name: <span class="string">'testObj'</span>,</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// 箭头函数自动绑定定义时所在的对象</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, () =&gt; <span class="keyword">this</span>.doSth(), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSth() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>5.1.1 箭头函数书写约定</li></ul><p>函数体只有单行语句时，允许写在同一行并去除花括号</p><p>当函数只有一个参数时，允许去除参数外层的括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">x</span> =&gt;</span> x + x; <span class="comment">// 注意此处会隐性return x + x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + x; <span class="comment">// 若函数体有花括号语句块时须进行显性的return</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map( <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><ul><li>5.1.2 用箭头函数返回一个对象，应用括号包裹</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="attr">x</span>: x &#125;; <span class="comment">// 花括号会变成语句块，不表示对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="params">x</span> =&gt;</span> (&#123; <span class="attr">x</span>: x &#125;); <span class="comment">// 使用括号可正确return &#123;x:x&#125;</span></span><br></pre></td></tr></table></figure><ul><li>5.2 立即调用函数 IIFE</li></ul><p>使用箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>5.3 不使用 <code>arguments</code>, 采用rest语法<code>...</code>代替</li></ul><p>rest参数是真正的数组，不需要再转换</p><p>注意：箭头函数中不能使用<code>arguments</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>5.4 函数参数指定默认值</li></ul><p>采用函数默认参数赋值语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;<span class="comment">// 此处有将0，''等假值转换掉为默认值的副作用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更加简洁，安全'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>5.5 对象中的函数方法使用缩写形式</li></ul><p>更加简洁</p><p>函数方法不要使用箭头函数，避免this指向的混乱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> shopObj = &#123;</span><br><span class="line">  des: <span class="string">'对象模块写法'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.des);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shopObj = &#123;</span><br><span class="line">  des: <span class="string">'对象模块写法'</span>,</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.des); <span class="comment">// 此处会变成undefined.des，因为指向顶层模块的this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> des = <span class="string">'对象模块写法'</span>; <span class="comment">// 使用对象属性值简写方式</span></span><br><span class="line"><span class="keyword">const</span> shopObj = &#123;</span><br><span class="line">  des,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.des);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li>6.1 类名应使用帕斯卡写法(<code>PascalCased</code>)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6.1.1 类名与花括号须保留一个空格间距</li></ul><p>类中的方法定义时, 方法名与左括号 <code>(</code> 之间【不保留】空格间距</p><p>类中的方法定义时，右括号 <code>)</code> 须与花括号 <code>{</code> 【保留】一个空格间距</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// 右括号 `)` 须与花括号 `&#123;` 仅保留一个空格间距</span></span><br><span class="line">  &#125;</span><br><span class="line">  sayHi()    &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  _say () &#123;</span><br><span class="line">    <span class="comment">// 方法名与左括号 `(` 之间【不保留】空格间距</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 右括号 `)` 须与花括号 `&#123;` 仅保留一个空格间距</span></span><br><span class="line">  &#125;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  _say() &#123;</span><br><span class="line">    <span class="comment">// 方法名与左括号 `(` 之间【不保留】空格间距</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>6.2 定义类时，方法的顺序如下：</p><ul><li><p><code>constructor</code></p></li><li><p>public <code>get/set</code> 公用访问器，<code>set</code>只能传一个参数</p></li><li><p>public methods 公用方法，公用相关命名使用小驼峰式写法(<code>lowerCamelCase</code>)</p></li><li><p>private <code>get/set</code> 私有访问器，私有相关命名应加上下划线 <code>_</code> 为前缀</p></li><li><p>private methods 私有方法</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get aval() &#123;</span><br><span class="line">    <span class="comment">// public getter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set aval(val) &#123;</span><br><span class="line">    <span class="comment">// public setter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doSth() &#123;</span><br><span class="line">    <span class="comment">// 公用方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get _aval() &#123;</span><br><span class="line">    <span class="comment">// private getter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set _aval() &#123;</span><br><span class="line">    <span class="comment">// private setter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _doSth() &#123;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6.3 如果不是class类，不使用<code>new</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure><ul><li>6.4 使用真正意思上的类Class写法，不使用<code>prototype</code>进行模拟扩展</li></ul><p>Class更加简洁，易维护</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">names = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._names = [...names];</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currName = <span class="keyword">this</span>._names[<span class="number">0</span>];</span><br><span class="line">  alert(<span class="string">`one one <span class="subst">$&#123;currName&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(names = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>._names = [...names];</span><br><span class="line">  &#125;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    <span class="keyword">const</span> currName = <span class="keyword">this</span>._names[<span class="number">0</span>];</span><br><span class="line">    alert(<span class="string">`one one <span class="subst">$&#123;currName&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6.5 class应先定义后使用</li></ul><p>class不存在hoist问题，应先定义class再实例化</p><p>使用继承时，应先定义父类再定义子类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubFoo</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubFoo</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6.6 <code>this</code>的注意事项</li></ul><p>子类使用<code>super</code>关键字时，<code>this</code>应在调用<code>super</code>之后才能使用</p><p>可在方法中<code>return this</code>来实现链式调用写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubFoo</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, z) &#123;</span><br><span class="line">    <span class="keyword">this</span>.z = z; <span class="comment">// 引用错误</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubFoo</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, z) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.z = z; <span class="comment">// this 放在 super 后调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  setHeight(height) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul><li>7.1 使用<code>import / export</code>来做模块加载导出，不使用非标准模块写法</li></ul><p>跟着标准走的人，运气总不会太差</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> colors  = <span class="built_in">require</span>(<span class="string">'./colors'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = color.lightRed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">import</span> &#123; lightRed &#125; <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lightRed;</span><br></pre></td></tr></table></figure><ul><li>7.1.1 <code>import / export</code> 后面采用花括号<code>{ }</code>引入模块的写法时，须在花括号内左右各保留一个空格</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">import</span> &#123;lightRed&#125; <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; lightRed&#125; <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">import</span> &#123; lightRed &#125; <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br></pre></td></tr></table></figure><ul><li>7.2 应确保每个module有且只有一个默认导出模块</li></ul><p>方便调用方使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">const</span> lightRed = <span class="string">'#F07'</span>;</span><br><span class="line"><span class="keyword">export</span> lightRed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> lightRed = <span class="string">'#F07'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lightRed;</span><br></pre></td></tr></table></figure><ul><li>7.3 <code>import</code> 不使用统配符 <code>*</code> 进行整体导入</li></ul><p>确保模块与模块之间的关系比较清晰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> colors <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">import</span> colors <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br></pre></td></tr></table></figure><ul><li>7.4 不要将<code>import</code>与<code>export</code>混合在一行</li></ul><p>分开导入与导出，让结构更清晰，可读性更强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">export</span> &#123; lightRed <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">import</span> &#123; lightRed &#125; <span class="keyword">from</span> <span class="string">'./colors'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lightRed;</span><br></pre></td></tr></table></figure><ul><li>7.5 多变量要导出时应采用对象解构形式</li></ul><p><code>export</code>置于底部，使欲导出变量更加清晰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> lightRed = <span class="string">'#F07'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> black  = <span class="string">'#000'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> white  = <span class="string">'#FFF'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">const</span> lightRed = <span class="string">'#F07'</span>;</span><br><span class="line"><span class="keyword">const</span> black  = <span class="string">'#000'</span>;</span><br><span class="line"><span class="keyword">const</span> white  = <span class="string">'#FFF'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; lightRed, black, white &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> work </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
