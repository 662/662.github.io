{"meta":{"title":662,"subtitle":"大唐高僧刘伯温","description":"不想当和尚的程序员不是一个好军师","author":"Meeko","url":"http://662.github.io"},"pages":[{"title":"","date":"2019-10-14T05:54:52.734Z","updated":"2019-10-14T05:54:52.734Z","comments":true,"path":"almanac/index.css","permalink":"http://662.github.io/almanac/index.css","excerpt":"","text":"/* body * { font-family:\"Consolas\",\"Microsoft Yahei\", Arial, sans-serif; } body { background: white; margin: 0; padding: 0; } */ .date_container { width: 320px; margin: 0 auto 50px; } .date_container>.title { color: #bbb; font-weight: bold; margin-bottom: 10px; background: #555; padding: 5px 15px; } .date_container .adlink { text-align: center; font-size: 11pt; } .date_container .adlink a { text-decoration: none; display:block; color: #666; font-weight: bold; margin-bottom: 10px; background: #eee; border: 1px solid #ddd; border-radius: 4px; padding: 10pt; margin-top: 10pt; } .date_container .date{ font-size:17pt; font-weight: bold; line-height: 30pt; text-align: center; } .date_container .split,.date_container .clear { clear: both; height: 1px; overflow-y: hidden; } .date_container .good, .date_container .bad { clear: both; position: relative; } .date_container .bad { /*top: -1px;*/ } .date_container .good .title,.date_container .bad .title { float: left; width: 100px; font-weight: bold; text-align: center; font-size: 30pt; position:absolute; top:0; bottom:0; } .date_container .good .title>table,.date_container .bad .title>table { position:absolute; width:100%; height:100%; border:none; } .date_container .good .title { background: #ffee44; } .date_container .someday .good .title { background: #aaaaaa; } .date_container .bad .title { background: #ff4444; color: #fff; } .date_container .someday .bad .title { background: #666666; color: #fff; } .date_container .good .content, .bad .content { margin-left: 115px; padding-right: 10px; padding-top: 1px; font-size:15pt; } .date_container .someday .good { background: #dddddd; } .date_container .someday .bad { background: #aaaaaa; } .date_container .good { background: #ffffaa; } .date_container .bad { background: #ffddd3; } .date_container .content ul { list-style: none; margin:10px 0 0; padding:0; } .date_container .content ul li { line-height:150%; font-size: 15pt; font-weight: bold; color: #444; } .date_container .content ul li div.description { font-size: 11pt; font-weight: normal; color: #777; line-height: 110%; margin-bottom: 10px; } .date_container .line-tip { font-size: 11pt; margin-top: 10px; margin-left: 10px; } .date_container .direction_value { color:#4a4; font-weight: bold; } .date_container .someday .direction_value { color:#888; } .date_container .goddes_value { color: #f87; } .date_container .someday .goddes_value { color: #777; } .date_container .comment { margin-top: 50px; font-size: 11pt; margin: 0 10px; } .date_container .comment ul { margin-left: 0; padding-left: 0; color: #999; }"},{"title":"","date":"2019-10-14T05:54:52.734Z","updated":"2019-10-14T05:54:52.734Z","comments":true,"path":"almanac/index.js","permalink":"http://662.github.io/almanac/index.js","excerpt":"","text":"// /* * 注意：本程序中的“随机”都是伪随机概念，以当前的天为种子。 */ function random(dayseed, indexseed) { var n = dayseed % 11117; for (var i = 0; i < 100 + indexseed; i++) { n = n * n; n = n % 11117; // 11117 是个质数 } return n; } var today = new Date(); var iday = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate(); var weeks = [\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"]; var directions = [\"北方\",\"东北方\",\"东方\",\"东南方\",\"南方\",\"西南方\",\"西方\",\"西北方\"]; var activities = [ {name:\"写单元测试\", good:\"写单元测试将减少出错\",bad:\"写单元测试会降低你的开发效率\"}, {name:\"洗澡\", good:\"你几天没洗澡了？\",bad:\"会把设计方面的灵感洗掉\", weekend: true}, {name:\"锻炼一下身体\", good:\"\",bad:\"能量没消耗多少，吃得却更多\", weekend: true}, {name:\"抽烟\", good:\"抽烟有利于提神，增加思维敏捷\",bad:\"除非你活够了，死得早点没关系\", weekend: true}, {name:\"白天上线\", good:\"今天白天上线是安全的\",bad:\"可能导致灾难性后果\"}, {name:\"重构\", good:\"代码质量得到提高\",bad:\"你很有可能会陷入泥潭\"}, {name:\"使用%t\", good:\"你看起来更有品位\",bad:\"别人会觉得你在装逼\"}, {name:\"跳槽\", good:\"该放手时就放手\",bad:\"鉴于当前的经济形势，你的下一份工作未必比现在强\"}, {name:\"招人\", good:\"你面前这位有成为牛人的潜质\",bad:\"这人会写程序吗？\"}, {name:\"面试\", good:\"面试官今天心情很好\",bad:\"面试官不爽，会拿你出气\"}, {name:\"提交辞职申请\", good:\"公司找到了一个比你更能干更便宜的家伙，巴不得你赶快滚蛋\",bad:\"鉴于当前的经济形势，你的下一份工作未必比现在强\"}, {name:\"申请加薪\", good:\"老板今天心情很好\",bad:\"公司正在考虑裁员\"}, {name:\"晚上加班\", good:\"晚上是程序员精神最好的时候\",bad:\"\", weekend: true}, {name:\"在妹子面前吹牛\", good:\"改善你矮穷挫的形象\",bad:\"会被识破\", weekend: true}, {name:\"撸管\", good:\"避免缓冲区溢出\",bad:\"强撸灰飞烟灭\", weekend: true}, {name:\"浏览成人网站\", good:\"重拾对生活的信心\",bad:\"你会心神不宁\", weekend: true}, {name:\"命名变量\\\"%v\\\"\", good:\"\",bad:\"\"}, {name:\"写超过%l行的方法\", good:\"你的代码组织的很好，长一点没关系\",bad:\"你的代码将混乱不堪，你自己都看不懂\"}, {name:\"提交代码\", good:\"遇到冲突的几率是最低的\",bad:\"你遇到的一大堆冲突会让你觉得自己是不是时间穿越了\"}, {name:\"代码复审\", good:\"发现重要问题的几率大大增加\",bad:\"你什么问题都发现不了，白白浪费时间\"}, {name:\"开会\", good:\"写代码之余放松一下打个盹，有益健康\",bad:\"小心被扣屎盆子背黑锅\"}, {name:\"打DOTA\", good:\"你将有如神助\",bad:\"你会被虐的很惨\", weekend: true}, {name:\"晚上上线\", good:\"晚上是程序员精神最好的时候\",bad:\"你白天已经筋疲力尽了\"}, {name:\"修复BUG\", good:\"你今天对BUG的嗅觉大大提高\",bad:\"新产生的BUG将比修复的更多\"}, {name:\"设计评审\", good:\"设计评审会议将变成头脑风暴\",bad:\"人人筋疲力尽，评审就这么过了\"}, {name:\"需求评审\", good:\"\",bad:\"\"}, {name:\"上微博\", good:\"今天发生的事不能错过\",bad:\"今天的微博充满负能量\", weekend: true}, {name:\"上AB站\", good:\"还需要理由吗？\",bad:\"满屏兄贵亮瞎你的眼\", weekend: true}, {name:\"玩FlappyBird\", good:\"今天破纪录的几率很高\",bad:\"除非你想玩到把手机砸了\", weekend: true} ]; var specials = [ {date:20140214, type:'bad', name:'待在男（女）友身边', description:'脱团火葬场，入团保平安。'} ]; var tools = [\"Eclipse写程序\", \"MSOffice写文档\", \"记事本写程序\", \"Windows8\", \"Linux\", \"MacOS\", \"IE\", \"Android设备\", \"iOS设备\"]; var varNames = [\"jieguo\", \"huodong\", \"pay\", \"expire\", \"zhangdan\", \"every\", \"free\", \"i1\", \"a\", \"virtual\", \"ad\", \"spider\", \"mima\", \"pass\", \"ui\"]; var drinks = [\"水\",\"茶\",\"红茶\",\"绿茶\",\"咖啡\",\"奶茶\",\"可乐\",\"鲜奶\",\"豆奶\",\"果汁\",\"果味汽水\",\"苏打水\",\"运动饮料\",\"酸奶\",\"酒\"]; function is_someday() { return today.getMonth() == 5 && today.getDate() == 4; } function getTodayString() { return \"今天是\" + today.getFullYear() + \"年\" + (today.getMonth() + 1) + \"月\" + today.getDate() + \"日 星期\" + weeks[today.getDay()]; } function star(num) { var result = \"\"; var i = 0; while (i < num) { result += \"★\"; i++; } while(i < 5) { result += \"☆\"; i++; } return result; } // 生成今日运势 function pickTodaysLuck() { var _activities = filter(activities); var numGood = random(iday, 98) % 3 + 2; var numBad = random(iday, 87) % 3 + 2; var eventArr = pickRandomActivity(_activities, numGood + numBad); var specialSize = pickSpecials(); for (var i = 0; i < numGood; i++) { addToGood(eventArr[i]); } for (var i = 0; i < numBad; i++) { addToBad(eventArr[numGood + i]); } } // 去掉一些不合今日的事件 function filter(activities) { var result = []; // 周末的话，只留下 weekend = true 的事件 if (isWeekend()) { for (var i = 0; i < activities.length; i++) { if (activities[i].weekend) { result.push(activities[i]); } } return result; } return activities; } function isWeekend() { return today.getDay() == 0 || today.getDay() == 6; } // 添加预定义事件 function pickSpecials() { var specialSize = [0,0]; for (var i = 0; i < specials.length; i++) { var special = specials[i]; if (iday == special.date) { if (special.type == 'good') { specialSize[0]++; addToGood({name: special.name, good: special.description}); } else { specialSize[1]++; addToBad({name: special.name, bad: special.description}); } } } return specialSize; } // 从 activities 中随机挑选 size 个 function pickRandomActivity(activities, size) { var picked_events = pickRandom(activities, size); for (var i = 0; i < picked_events.length; i++) { picked_events[i] = parse(picked_events[i]); } return picked_events; } // 从数组中随机挑选 size 个 function pickRandom(array, size) { var result = []; for (var i = 0; i < array.length; i++) { result.push(array[i]); } for (var j = 0; j < array.length - size; j++) { var index = random(iday, j) % result.length; result.splice(index, 1); } return result; } // 解析占位符并替换成随机内容 function parse(event) { var result = {name: event.name, good: event.good, bad: event.bad}; // clone if (result.name.indexOf('%v') != -1) { result.name = result.name.replace('%v', varNames[random(iday, 12) % varNames.length]); } if (result.name.indexOf('%t') != -1) { result.name = result.name.replace('%t', tools[random(iday, 11) % tools.length]); } if (result.name.indexOf('%l') != -1) { result.name = result.name.replace('%l', (random(iday, 12) % 247 + 30).toString()); } return result; } // 添加到“宜” function addToGood(event) { $('.good .content ul').append('' + event.name + '' + event.good + ''); } // 添加到“不宜” function addToBad(event) { $('.bad .content ul').append('' + event.name + '' + event.bad + ''); } $(function(){ if (is_someday()) {document.body.className = 'someday'}; $('.date').html(getTodayString()); $('.direction_value').html(directions[random(iday, 2) % directions.length]); $('.drink_value').html(pickRandom(drinks,2).join('，')); $('.goddes_value').html(star(random(iday, 6) % 5 + 1)); pickTodaysLuck(); });"},{"title":"","date":"2019-10-14T05:54:52.735Z","updated":"2019-10-14T05:54:52.735Z","comments":true,"path":"guestbook/index.html","permalink":"http://662.github.io/guestbook/index.html","excerpt":"","text":"留言欢迎大家给我留言，一起交流！"},{"title":"关于","date":"2019-10-14T05:54:52.734Z","updated":"2019-10-14T05:54:52.734Z","comments":false,"path":"about/index.html","permalink":"http://662.github.io/about/index.html","excerpt":"","text":"Github: 662"},{"title":"程序员老黄历","date":"2019-10-14T05:54:52.734Z","updated":"2019-10-14T05:54:52.734Z","comments":false,"path":"almanac/index.html","permalink":"http://662.github.io/almanac/index.html","excerpt":"","text":"一个广为流传的程序员老黄历，首发于runjs.cn，作者没有留下任何声明。 程序员老黄历 beta 宜 不宜 座位朝向：面向 写程序，BUG 最少。 今日宜饮： 女神亲近指数： 本老黄历尚处于beta阶段，作者随时会修改，所以如果上午看到的内容跟下午不同，请勿惊慌； 本老黄历仅面向程序员； 本老黄历内容是程序生成的，因为只有这样程序员才会信。"}],"posts":[{"title":"SS服务器搭建教程","slug":"vultr-ss-bbr-kcptun","date":"2019-04-20T10:29:10.000Z","updated":"2019-10-14T05:54:52.734Z","comments":true,"path":"2019/04/20/vultr-ss-bbr-kcptun/","link":"","permalink":"http://662.github.io/2019/04/20/vultr-ss-bbr-kcptun/","excerpt":"","text":"本文旨在快速学习Linux搭建 shadowsocks 服务(以下简称ss)，并利用 bbr 和 kcp 进行加速，然后在 windows/ios 设备上愉悦地网上冲浪。 注意：本文基于你对 linux 操作系统有简单的认知和理解，所以本文并不适合纯小白 以下是需要用到的资源 一台可访国际互联网的服务器 ss 服务端一键安装脚本：ss-fly kcptun 服务端：kcptun（非必须） kcptun 客户端：kcptun（非必须) ss windows 客户端：shadowsocks-windows ss ios 客户端：potatso lite 一、 获取服务器选购一台廉价的海外服务器就足够了，本文使用 vultr 提供的 vps，目前最便宜的是$3.5一个月。使用下面的推广链接可获得$50首冲赠送。 推广链接：https://www.vultr.com/?ref=8030646-4F 注意：推广活动是限时的，如果点击过去发现无效，就表示活动过期了。 二、 安装ss服务端服务端的安装方式有很多，本文选用 @flyzy2005 编写的 ss-fly 一键安装脚本。 第一步：clone代码到本地1git clone https://github.com/flyzy2005/ss-fly 第二步：运行安装脚本1ss-fly/ss-fly.sh -i yourpassword 8080 其中yourpassword是 ss 连接密码，8080是端口号。 等待安装完成即可，安装完成之后服务会自动运行，并会开机自启。 如果需要修改密码或者端口，只需要重新运行一次安装脚本，或者直接修改/etc/shadowsocks.json这个配置文件。 相关操作123456/etc/init.d/ss-fly start # 启动/etc/init.d/ss-fly stop # 停止/etc/init.d/ss-fly restart # 重启/etc/init.d/ss-fly status # 查看状态ss-fly/ss-fly.sh -sslink # 查看连接vi /etc/shadowsocks.json # 修改配置 第三步：验证服务状态这一步并不是必须的，而是为了检查 ss 服务是否在正常运行，并能被外部网络访问 在服务器上执行1netstat -lntup 检查输出结果是否有一个被 python 监听的8080端口，如果有就说明 ss 服务已经启动。 在本地执行1telnet yourserverip 8080 其中yourserverip是你的服务器 ip，如果连接成功，就表示 ss 服务已经能被外部网络访问。 如果没有telnet这个命令，可以在控制面板 &gt; 程序和功能 &gt; 启用或关闭 Windows 功能中勾选Telnet Client并安装。 如果telnet连接失败，可以检查以下几个方面： 服务器防火墙是否开放8080端口（ss-fly 在安装过程中会自动配置防火墙开放8080）； 服务器提供商的防火墙策略是否开放8080（vultr 默认无防火墙）； 你所在的网络是否允许访问8080，由于一些企业的防火墙策略只允许访问常用端口，所以本文使用的是8080这种比较常用的端口； 三、 安装SS客户端ss 客户端也有很多，本文选用 shadowsocks-windows，使用方法非常简单，填写好服务器地址`服务器端口密码`就可以正常使用了，记得更新PAC配置。 到这里，ss 服务端和 windows 客户端就已经安装完成了，已经可以正常的网上冲浪了。 如果你觉得冲浪的速度有点差强人意，那么你可以继续进行下面的步骤。 四、 开启BBR加速bbr 是 @google 开源的一套内核加速算法，可以让你搭建的 shadowsocks 速度上一个台阶。 本文使用的ss-fly一键安装脚本已经集成了bbr的一键安装，所以我们只需要在服务器上运行以下脚本就可以开启bbr加速了。 1ss-fly/ss-fly.sh -bbr 注意：安装完成之后需要重启系统才能生效。 检测bbr加速是否开启，可以输入以下脚本： 1sysctl net.ipv4.tcp_available_congestion_control 如果返回类似以下这种后面含有bbr的内容，则说明已经成功开启了。 1net.ipv4.tcp_available_congestion_control = bbr cubic reno 到这里，你不但完成了 ss 服务端和 windows 客户端的安装，还对服务端的 ss 进行了 bbr 加速。 这基本能满足大多数冲浪需求了，但如果你像本文一样，购买的是非常廉价而且又远在美利坚的 vps，每到晚上速度就会慢得让人接受不了，那么你可以继续下面的步骤。 五、 使用KCPTUN进行加速kcptun 是由 @xtaci 基于 kcp 协议的golang实现。KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。 注意：使用kcptun会增加流量的开支 但是对于本文中使用的 vultr vps 最低配，也就是 500G/month 的流量限制，完全能够负担。 下载最新版的kcptun打开 https://github.com/xtaci/kcptun/releases 在服务器上下载最新版的kcptun服务端kcptun-linux-amd64-20xxxxxx.tar.gz 12# 本文使用的 v20190418wget https://github.com/xtaci/kcptun/releases/download/v20190418/kcptun-linux-amd64-20190418.tar.gz 解压之后启动服务 12./server_linux_amd64 -t \"yourssip:8080\" -l \":8081\" -mode fast3 -nocomp -sockbuf 16777217 -dscp 46 --key yourpassword# 这里是直接在当前服务器会话运行的，你可以使用 nohup 让它在后台运行，也可以注册成 systemd 服务让它以服务的形式启动 其中yourssip是你的 ss 服务器 ip，在本文中 ss 和 kcptun 部署在同一服务器，所以这里直接填写服务器的 ip 地址，8080是你的 ss 端口，8081是你准备让kcptun监听的端口，yourpassword是你的kcptun密码。 你任然可以使用netstat -lntup来查看8081端口的监听情况，以便确认kcptun是否启动成功 这样，kcptun 服务端就已经部署好了 接下来下载最新版的 windows 客户端kcptun-windows-amd64-20xxxxxx.tar.gz，解压之后会发现里面包含 windows 服务端和客户端文件，由于我们的服务端已经部署在 linux 上，所以我们只需要名为client_windows_amd64.exe的客户端文件。 我们用cmd运行以下脚本 1client_windows_amd64.exe -r \"KCP_SERVER_IP:8081\" -l \":1000\" -mode fast3 -nocomp -sockbuf 16777217 -dscp 46 --key yourpassword 其中KCP_SERVER_IP是你的kcptun所在服务器的 ip，8081是你的kcptun监听的端口，:1000是你的kcptun客户端准备监听的本地端口，yourpassword是你的kcptun密码。 这样我们的kcptun客户端就已经成功连接到了我们的kcptun服务端，接下来我们只需要修改一下我们的shadowsocks-windows客户端的配置，让shadowsocks-windows不把数据发送到 ss 服务器，而是把数据发送到本地的kcptun，就能实现我们的kcptun加速了。 1# ss客户端 -&gt; kcptun客户端 -&gt; kcptun服务端 -&gt; ss服务端 shadowsocks-windows 配置修改 将服务器地址改为127.0.0.1，将服务器端口改为1000，确认之后就可以享受kcptun加速带来的稳定和快乐了。 六、整合shadowsocks-windows和kcptun客户端到上一步的时候，由于我们在客户端每次都要开启两个程序（kcptun客户端、ss客户端），所以在使用上显得并不那么优雅。好在shadowsocks-windows提供了插件的支持，我们可以把kcptun以插件的形式加载到shadowsocks-windows，使得我们只需要启动shadowsocks-windows就可以愉快的冲浪。 复制client_windows_amd64.exe到shadowsocks-windows目录； 修改shadowsocks-windows配置，将服务器地址改为ss服务器地址，将服务器端口改为8081（服务端kcptun监听的端口），插件程序填写client_windows_amd64.exe，插件参数填写以下内容12-r %SS_REMOTE_HOST%:%SS_REMOTE_PORT% -l %SS_LOCAL_HOST%:%SS_LOCAL_PORT% --mode fast3 --nocomp --sockbuf 16777217 --dscp 46 --key kcptunpassword# kcptunpassword 是你的 kcptun 密码 确认之后就可以享受kcptun加速带来的稳定和快乐了。 七、 IOS客户端国区已经没有好用的 ss 客户端了，本文使用的 potatso lite 也需要在美区才能下载，关于如何切换美区，或者注册美区账号，以下提供简要的说明，避免大家踩坑根本没有人会浏览到我的博客，哪儿来的大家。 需要能访问真正互联网的网络，推荐使用 nuts 的 ios 版； 不要用 wifi 代理，用代理无法访问 appstore； 需要一个美国身份的生成器，不要乱填，乱填无法通过验证，推荐使用 fake name generator","categories":[{"name":"ladder","slug":"ladder","permalink":"http://662.github.io/categories/ladder/"}],"tags":[{"name":"ss","slug":"ss","permalink":"http://662.github.io/tags/ss/"},{"name":"vultr","slug":"vultr","permalink":"http://662.github.io/tags/vultr/"},{"name":"bbr","slug":"bbr","permalink":"http://662.github.io/tags/bbr/"},{"name":"kcptun","slug":"kcptun","permalink":"http://662.github.io/tags/kcptun/"},{"name":"potatso","slug":"potatso","permalink":"http://662.github.io/tags/potatso/"}]},{"title":"git分支管理","slug":"git-branch-management","date":"2018-03-08T12:17:08.000Z","updated":"2018-03-08T12:42:16.000Z","comments":true,"path":"2018/03/08/git-branch-management/","link":"","permalink":"http://662.github.io/2018/03/08/git-branch-management/","excerpt":"1. 总览git 的分支整体预览图如下 从上图可以看到主要包含下面几个分支： master: 主分支，主要用来版本发布。 develop：日常开发分支，该分支正常保存了开发的最新代码。 feature：具体的功能开发分支，只与 develop 分支交互。 release：release 分支可以认为是 master 分支的未测试版。比如说某一期的功能全部开发完成，那么就 将 develop 分支合并到 release 分支，测试没有问题并且到了发布日期就合并到 master 分支，进行发 布。 hotfix：线上 bug 修复分支。","text":"1. 总览git 的分支整体预览图如下 从上图可以看到主要包含下面几个分支： master: 主分支，主要用来版本发布。 develop：日常开发分支，该分支正常保存了开发的最新代码。 feature：具体的功能开发分支，只与 develop 分支交互。 release：release 分支可以认为是 master 分支的未测试版。比如说某一期的功能全部开发完成，那么就 将 develop 分支合并到 release 分支，测试没有问题并且到了发布日期就合并到 master 分支，进行发 布。 hotfix：线上 bug 修复分支。 2. 主分支主分支包括 master 分支和 develop 分支。master 分支用来发布，HEAD 就是当前线上的运行代码。develop 分支就是我们的日常开发。使用这两个分支就具有了最简单的开发模式：develop 分支用来开发功能，开发完成并且测试没有问题则将 develop 分支的代码合并到 master 分支并发布。 这引入了几个问题： develop 分支只有发布完了才能进行下一个版本开发，开发会比较缓慢。 线上代码出现 bug 如何进行 bug 修复。 带着这两个问题往下看。 3. 辅助分支主要介绍的辅助分支如下： feature 分支 release 分支 hotfix 分支 通过这些分支，我们可以做到：团队成员之间并行开发，feature track 更加容易，开发和发布并行以及线上问题修复。 3.1 Feature 分支feature 分支用来开发具体的功能，一般 fork 自 develop 分支，最终可能会合并到 develop 分支。比如我们要在下一个版本增加功能1、功能2、功能3。那么我们就可以起三个feature 分支：feature1，feature2，feature3。（feature 分支命名最好能够自解释，这并不是一种好的命名。）随着我们开发，功能1和功能2都被完成了，而功能3因为某些原因完成不了，那么最终 feature1 和 feature2 分支将被合并到 develop 分支，而 feature3 分支将被干掉。 3.2 Release 分支release 分支在我看来是 pre-master。release 分支从 develop 分支 fork 出来，最终会合并到 develop 分支和 master 分支。合并到 master 分支上就是可以发布的代码了。有人可能会问那为什么合并回 develop 分支呢？很简单，有了 release 分支，那么相关的代码修复就只会在 release 分支上改动了，最后必然要合并到 develop 分支。 我们最初所有的开发工作都在 develop 分支上，当我们这一期的功能开发完毕的时候，我们基于 develop 分支开一个新的 release 分支。这个时候我们就可以对 release 分支做统一的测试了，另外做一些发布准备工作：比如版本号之类的。 如果测试工作或者发布准备工作和具体的开发工作由不同人来做，比如国内的 RD 和 QA，这个 RD 就可以继续基于 develop 分支继续开发了。再或者说公司对于发布有严格的时间控制，开发工作提前并且完美的完成了，这个时候我们就可以在 develop 分支上继续我们下一期的开发了。同时如果测试有问题的话，我们将直接在 release 分支上修改，然后将修改合并到 develop 分支上。 待所有的测试和准备工作做完之后，我们就可以将 release 分支合并到 master 分支上，并进行发布了。 3.3 Hotfix 分支顾名思义，hotfix 分支用来修复线上 bug。当线上代码出现 bug 时，我们基于 master 分支开一个 hotfix 分支，修复 bug 之后再将 hotfix 分支合并到 master 分支并进行发布，同时 develop 分支作为最新最全的代码分支，hotfix 分支也需要合并到 develop 分支上去。仔细想一想，其实 hotfix 分支和 release 分支功能类似。hotfix 的好处是不打断 develop 分支正常进行，同时对于现实代码的修复貌似也没有更好的方法了（总不能直接修改 master 代码吧:D）。 参考 A successful Git branching model","categories":[{"name":"work","slug":"work","permalink":"http://662.github.io/categories/work/"}],"tags":[{"name":"git","slug":"git","permalink":"http://662.github.io/tags/git/"}]},{"title":"关于Nginx中“no resolver defined to resolve xxx.xxx“的问题","slug":"nginx-error-no-resolver-defined-to-resolve","date":"2017-04-23T12:50:02.000Z","updated":"2019-10-14T05:54:52.733Z","comments":true,"path":"2017/04/23/nginx-error-no-resolver-defined-to-resolve/","link":"","permalink":"http://662.github.io/2017/04/23/nginx-error-no-resolver-defined-to-resolve/","excerpt":"","text":"在 Nginx 配置文件中使用变量来存放一个http地址时，如果这个地址是域名而不是IP，如下所示： 1234567set $server_domain \"http://yourdomain:8080\";location ^~ /api &#123; proxy_pass $server_domain; rewrite ^/api/?(.*)$ \"/$1\" break; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr;&#125; 这个配置中的代理是会出错的，错误信息是 1no resolver defined to resolve yourdomain 但是如果我们不申明变量 $server_domain，而是直接设置 proxy_pass 123456location ^~ /api &#123; proxy_pass http://yourdomain:8080; rewrite ^/api/?(.*)$ \"/$1\" break; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr;&#125; 这时候代理就会生效，毫无问题 原因是 Nginx 0.6.18以后的版本中启用了一个resolver指令，在使用变量来构造某个server地址的时候一定要用resolver指令来指定DNS服务器的地址，所以解决这个问题的方法很简单：在nginx的配置文件中的http{}部分添加一行DNS地址即可 1resolver 8.8.8.8; 此外，如果有ipv6环境的机器，还可以加上ipv6=off指令，避免一些奇葩原因导致的no resolver defined to resolve错误。 1resolver 8.8.8.8 ipv6=off;","categories":[{"name":"work","slug":"work","permalink":"http://662.github.io/categories/work/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://662.github.io/tags/nginx/"}]},{"title":"ECMAScript6 编码规范","slug":"ecmascript6-coding-standards","date":"2016-07-09T09:18:02.000Z","updated":"2019-10-14T05:54:52.731Z","comments":true,"path":"2016/07/09/ecmascript6-coding-standards/","link":"","permalink":"http://662.github.io/2016/07/09/ecmascript6-coding-standards/","excerpt":"","text":"本规范是基于JavaScript规范拟定的，只针对ES6相关内容进行约定 如变量命名，是否加分号等约定的请参考JavaScript规范 应注意目前的代码转换工具(如Babel，Traceur)不够完善,有些特性须谨慎使用 规范内容 声明 Declarations 字符串 Strings 解构 Destructuring 数组 Arrays 函数 Functions 类 Classes 模块 Modules 声明 1.1 变量 对于只在当前作用域下有效的变量，应使用let来代替var 对于全局变量声明，采用var，但应避免声明过多全局变量污染环境 12345678910111213141516171819// 不好const variables;const globalObj = null; // 不是常量let globalObj = null;for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i); // 4// 好let variables;var globalObj = null;for (let i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i); // ReferenceError: i is not defined 1.2 常量 对于常量应使用const进行声明，命名采用驼峰写法 对于使用 immutable 数据应用const进行声明 注意: const与let只在声明所在的块级作用域内有效 12345678910111213141516// 不好let someNum = 123;const AnotherStr = '不变的字符串';let arr = ['不', '变', '数', '组'];var ANOTHER_OBJ = &#123; '不变对象': true&#125;;// 好const someNum = 123;const anotherStr = '不变的字符串';const arr = ['不', '变', '数', '组'];const anotherObj = &#123; '不变对象': true&#125;; 字符串 2.1 处理多行字符串,使用模板字符串 以反引号( ` )标示 可读性更强，代码更易编写 注意排版引起空格的问题，使用场景为声明HTML模板字符串 1234567891011// 不好const tmpl = '&lt;div class=\"content\"&gt; \\n' + '&lt;h1&gt;这是换行了。&lt;/h1&gt; \\n' + '&lt;/div&gt;';// 好const tmpl = `&lt;div class=\"content\"&gt; &lt;h1&gt;这是换行了。&lt;/h1&gt;&lt;/div&gt;`; 2.2 处理字符串拼接变量时,使用模板字符串 12345678910// 不好function sayHi(name) &#123; return 'How are you, ' + name + '?';&#125;// 好function sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; 解构 3.1 嵌套结构的对象层数不能超过3层 12345678910111213141516171819202122232425// 不好let obj = &#123; 'one': [ &#123; 'newTwo': [ &#123; 'three': [ 'four': '太多层了，头晕晕' ] &#125; ] &#125; ]&#125;;// 好let obj = &#123; 'one': [ 'two', &#123; 'twoObj': '结构清晰' &#125; ]&#125;; 3.2 解构语句中统一不使用圆括号 1234567// 不好[(a)] = [11]; // a未定义let &#123; a: (b) &#125; = &#123;&#125;; // 解析出错// 好let [a, b] = [11, 22]; 3.3 对象解构 对象解构 元素与顺序无关 对象指定默认值时仅对恒等于undefined ( !== null ) 的情况生效 3.3.1 若函数形参为对象时，使用对象解构赋值 1234567891011121314151617// 不好function someFun(opt) &#123; let opt1 = opt.opt1; let opt2 = opt.opt2; console.log(op1);&#125;// 好function someFun(opt) &#123; let &#123; opt1, opt2 &#125; = opt; console.log(`$(opt1) 加上 $(opt2)`);&#125;function someFun(&#123; opt1, opt2 &#125;) &#123; console.log(opt1);&#125; 3.3.2 若函数有多个返回值时，使用对象解构，不使用数组解构，避免添加顺序的问题 12345678910111213141516// 不好function anotherFun() &#123; const one = 1, two = 2, three = 3; return [one, two, three];&#125;const [one, three, two] = anotherFun(); // 顺序乱了// one = 1, two = 3, three = 2// 好function anotherFun() &#123; const one = 1, two = 2, three = 3; return &#123; one, two, three &#125;;&#125;const &#123; one, three, two &#125; = anotherFun(); // 不用管顺序// one = 1, two = 2, three = 3 3.3.3 已声明的变量不能用于解构赋值（语法错误） 123// 语法错误let a;&#123; a &#125; = &#123; b: 123&#125;; 3.4 数组解构 数组元素与顺序相关 3.4.1 交换变量的值 123456789101112let x = 1;let y = 2;// 不好let temp;temp = x;x = y;y = temp;// 好[x, y] = [y, x]; // 交换变量 3.4.2 将数组成员赋值给变量时，使用数组解构 123456789const arr = [1, 2, 3, 4, 5];// 不好const one = arr[0];const two = arr[1];// 好const [one, two] = arr; 数组 4.1 将类数组(array-like)对象与可遍历对象(如Set, Map)转为真正数组 采用Array.from进行转换 12345678910// 不好function foo() &#123; let args = Array.prototype.slice.call(arguments);&#125;// 好function foo() &#123; let args = Array.from(arguments);&#125; 4.2 数组去重 结合Set结构与Array.from 使用indexOf，HashTable等形式，不够简洁清晰 1234// 好function deduplication(arr) &#123; return Array.from(new Set(arr));&#125; 4.3 数组拷贝 采用数组扩展...形式 123456789101112const items = [1, 2, 3];// 不好const len = items.length;let copyTemp = [];for (let i = 0; i &lt; len; i++) &#123; copyTemp[i] = items[i];&#125;// 好let copyTemp = [...items]; 4.4 将一组数值转为数组 采用Array.of进行转换 12345678// 不好let arr1 = new Array(2); // [undefined x 2]let arr2 = new Array(1, 2, 3); // [1, 2, 3]// 好let arr1 = Array.of(2); // [2]let arr2 = Array.of(1, 2, 3); // [1, 2, 3] 函数 5.1 当要用函数表达式或匿名函数时，使用箭头函数(Arrow Functions) 箭头函数更加简洁，并且绑定了this 1234567891011121314151617181920212223242526272829303132333435363738394041// 不好const foo = function(x) &#123; console.log(foo.name); // 返回'' ，函数表达式默认省略name属性&#125;;[1, 2, 3].map(function(x) &#123; return x + 1;&#125;);var testObj = &#123; name: 'testObj', init() &#123; var _this = this; // 保存定义时的this引用 document.addEventListener('click', function() &#123; return _this.doSth(); &#125;, false); &#125;, doSth() &#123; console.log(this.name); &#125;&#125;;// 好const foo = (x) =&gt; &#123; console.log(foo.name); // 返回'foo'&#125;;[1, 2, 3].map( (x) =&gt; &#123; return x + 1;&#125;);var testObj = &#123; name: 'testObj', init() &#123; // 箭头函数自动绑定定义时所在的对象 document.addEventListener('click', () =&gt; this.doSth(), false); &#125;, doSth() &#123; console.log(this.name); &#125;&#125;; 5.1.1 箭头函数书写约定 函数体只有单行语句时，允许写在同一行并去除花括号 当函数只有一个参数时，允许去除参数外层的括号 12345678// 好const foo = x =&gt; x + x; // 注意此处会隐性return x + xconst foo = (x) =&gt; &#123; return x + x; // 若函数体有花括号语句块时须进行显性的return&#125;; [1, 2, 3].map( x =&gt; x * x); 5.1.2 用箭头函数返回一个对象，应用括号包裹 123456// 不好let test = x =&gt; &#123; x: x &#125;; // 花括号会变成语句块，不表示对象// 好let test = x =&gt; (&#123; x: x &#125;); // 使用括号可正确return &#123;x:x&#125; 5.2 立即调用函数 IIFE 使用箭头函数 12345678910// 不好(function() &#123; console.log('哈');&#125;)();// 好(() =&gt; &#123; console.log('哈');&#125;)(); 5.3 不使用 arguments, 采用rest语法...代替 rest参数是真正的数组，不需要再转换 注意：箭头函数中不能使用arguments对象 1234567891011// 不好function foo() &#123; let args = Array.prototype.slice.call(arguments); return args.join('');&#125;// 好function foo(...args) &#123; return args.join('');&#125; 5.4 函数参数指定默认值 采用函数默认参数赋值语法 12345678910// 不好function foo(opts) &#123; opts = opts || &#123;&#125;;// 此处有将0，''等假值转换掉为默认值的副作用&#125;// 好function foo(opts = &#123;&#125;) &#123; console.log('更加简洁，安全');&#125; 5.5 对象中的函数方法使用缩写形式 更加简洁 函数方法不要使用箭头函数，避免this指向的混乱 1234567891011121314151617181920212223// 不好const shopObj = &#123; des: '对象模块写法', foo: function() &#123; console.log(this.des); &#125;&#125;;const shopObj = &#123; des: '对象模块写法', foo: () =&gt; &#123; console.log(this.des); // 此处会变成undefined.des，因为指向顶层模块的this &#125;&#125;;// 好const des = '对象模块写法'; // 使用对象属性值简写方式const shopObj = &#123; des, foo() &#123; console.log(this.des); &#125;&#125;; 类 6.1 类名应使用帕斯卡写法(PascalCased) 1234// 好class SomeClass &#123;&#125; 6.1.1 类名与花括号须保留一个空格间距 类中的方法定义时, 方法名与左括号 ( 之间【不保留】空格间距 类中的方法定义时，右括号 ) 须与花括号 { 【保留】一个空格间距 123456789101112131415161718192021222324252627// 不好class Foo&#123; constructor()&#123; // 右括号 `)` 须与花括号 `&#123;` 仅保留一个空格间距 &#125; sayHi() &#123; &#125; _say () &#123; // 方法名与左括号 `(` 之间【不保留】空格间距 &#125; &#125;// 好class Foo &#123; constructor() &#123; // 右括号 `)` 须与花括号 `&#123;` 仅保留一个空格间距 &#125; sayHi() &#123; &#125; _say() &#123; // 方法名与左括号 `(` 之间【不保留】空格间距 &#125;&#125; 6.2 定义类时，方法的顺序如下： constructor public get/set 公用访问器，set只能传一个参数 public methods 公用方法，公用相关命名使用小驼峰式写法(lowerCamelCase) private get/set 私有访问器，私有相关命名应加上下划线 _ 为前缀 private methods 私有方法 123456789101112131415161718192021222324252627282930// 好class SomeClass &#123; constructor() &#123; // constructor &#125; get aval() &#123; // public getter &#125; set aval(val) &#123; // public setter &#125; doSth() &#123; // 公用方法 &#125; get _aval() &#123; // private getter &#125; set _aval() &#123; // private setter &#125; _doSth() &#123; // 私有方法 &#125;&#125; 6.3 如果不是class类，不使用new 123456789101112// 不好function Foo() &#123;&#125;const foo = new Foo();// 好class Foo &#123;&#125;const foo = new Foo(); 6.4 使用真正意思上的类Class写法，不使用prototype进行模拟扩展 Class更加简洁，易维护 12345678910111213141516171819// 不好function Dog(names = []) &#123; this._names = [...names];&#125;Dog.prototype.bark = function() &#123; const currName = this._names[0]; alert(`one one $&#123;currName&#125;`);&#125;// 好class Dog &#123; constructor(names = []) &#123; this._names = [...names]; &#125; bark() &#123; const currName = this._names[0]; alert(`one one $&#123;currName&#125;`); &#125;&#125; 6.5 class应先定义后使用 class不存在hoist问题，应先定义class再实例化 使用继承时，应先定义父类再定义子类 123456789101112131415161718// 不好let foo = new Foo();class SubFoo extends Foo &#123;&#125;class Foo &#123;&#125;// 好class Foo &#123;&#125;let foo = new Foo();class SubFoo extends Foo &#123;&#125; 6.6 this的注意事项 子类使用super关键字时，this应在调用super之后才能使用 可在方法中return this来实现链式调用写法 123456789101112131415161718192021222324252627class Foo &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;// 不好class SubFoo extends Foo &#123; constructor(x, y, z) &#123; this.z = z; // 引用错误 super(x, y); &#125;&#125;// 好class SubFoo extends Foo &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; // this 放在 super 后调用 &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125; 模块 7.1 使用import / export来做模块加载导出，不使用非标准模块写法 跟着标准走的人，运气总不会太差 123456789// 不好const colors = require('./colors');module.exports = color.lightRed;// 好import &#123; lightRed &#125; from './colors';export default lightRed; 7.1.1 import / export 后面采用花括号{ }引入模块的写法时，须在花括号内左右各保留一个空格 123456// 不好import &#123;lightRed&#125; from './colors';import &#123; lightRed&#125; from './colors';// 好import &#123; lightRed &#125; from './colors'; 7.2 应确保每个module有且只有一个默认导出模块 方便调用方使用 12345678// 不好const lightRed = '#F07';export lightRed;// 好const lightRed = '#F07';export default lightRed; 7.3 import 不使用统配符 * 进行整体导入 确保模块与模块之间的关系比较清晰 12345// 不好import * as colors from './colors';// 好import colors from './colors'; 7.4 不要将import与export混合在一行 分开导入与导出，让结构更清晰，可读性更强 123456// 不好export &#123; lightRed as default &#125; from './colors';// 好import &#123; lightRed &#125; from './colors';export default lightRed; 7.5 多变量要导出时应采用对象解构形式 export置于底部，使欲导出变量更加清晰 1234567891011// 不好export const lightRed = '#F07';export const black = '#000';export const white = '#FFF';// 好const lightRed = '#F07';const black = '#000';const white = '#FFF';export default &#123; lightRed, black, white &#125;;","categories":[{"name":"work","slug":"work","permalink":"http://662.github.io/categories/work/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://662.github.io/tags/es6/"}]}]}